<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hebrew Flashcards</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            background: #111;
            color: #f5f5f5;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            padding: 1rem 1.2rem;
            text-align: center;
            font-size: 1.1rem;
            background: #181818;
            border-bottom: 1px solid #333;
        }
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0.8rem 1.2rem 1.2rem;
            gap: 0.8rem;
        }
        #status {
            font-size: 0.9rem;
            color: #bbb;
        }
        #docSelector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .doc-btn {
            padding: 0.4rem 0.8rem;
            border-radius: 999px;
            border: 1px solid #444;
            background: transparent;
            color: #bbb;
            font-size: 0.85rem;
            cursor: pointer;
            font-weight: 400;
        }
        .doc-btn.active {
            background: #2e7dff;
            border-color: #2e7dff;
            color: #fff;
            font-weight: 500;
        }
        #lectures {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.2rem;
        }
        .lecture-chip {
            padding: 0.3rem 0.7rem;
            border-radius: 999px;
            border: 1px solid #444;
            font-size: 0.85rem;
            cursor: pointer;
            user-select: none;
            line-height: 1.2;
            text-align: left;

        }
        .lecture-chip input {
            display: none;
        }
        .lecture-chip.selected {
            background: #2e7dff;
            border-color: #2e7dff;
            color: #fff;
        }
        #controls {
            display: flex;
            gap: 0.6rem;
            align-items: center;
            margin-top: 0.4rem;
        }
        button {
            padding: 0.5rem 0.9rem;
            border-radius: 999px;
            border: none;
            background: #2e7dff;
            color: #fff;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
        }
        button:disabled {
            opacity: 0.5;
            cursor: default;
        }
        #modeLabel {
            font-size: 0.85rem;
            color: #bbb;
        }
        #card {
            margin-top: 0.8rem;
            flex: 1;
            border-radius: 1rem;
            border: 1px solid #333;
            background: #181818;
            padding: 1.2rem 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            user-select: none;
        }
        #cardHint {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 0.6rem;
        }
        #question {
            font-size: 1.4rem;
            margin-bottom: 0.6rem;
            line-height: 1.3;
        }
        .hebrew-audio {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-decoration-color: #666;
            transition: all 0.2s;
        }
        .hebrew-audio:hover {
            color: #2e7dff;
            text-decoration-color: #2e7dff;
        }
        #answer {
            font-size: 1rem;
            color: #ddd;
            min-height: 1.2em;
            line-height: 1.4;
        }
        #footer {
            font-size: 0.8rem;
            color: #777;
            text-align: center;
            padding: 0.4rem 0.8rem 0.8rem;
        }
    </style>
</head>
<body>
<header>
    Hebrew Flashcards
</header>
<main>
    <div id="status">Loading words from Google Doc‚Ä¶</div>

    <div id="docSelector">
        <button class="doc-btn active" data-doc="thematic">By Theme</button>
        <button class="doc-btn" data-doc="chronological">Chronological</button>
    </div>

    <div id="lectures"></div>

    <div id="controls">
        <button id="startBtn" disabled>Start</button>
        <div id="modeLabel"></div>
    </div>

    <div id="card">
        <div id="cardHint">Choose lectures and press Start.</div>
        <div id="question"></div>
        <div id="answer"></div>
    </div>
</main>
<div id="footer">
    Tap card once to reveal, tap again for the next word.
</div>

<script>

    function dbg(label, value) {
    console.log(`[DEBUG] ${label}:`, value);
    }


    function normalizeGoogleDocUrl(url) {
    if (url.includes("/pub")) {
        return url.replace(/\/pub(\?.*)?$/, "/pub?output=txt");
    }
    if (url.includes("/export")) {
        return url;
    }
    throw new Error("Unsupported Google Docs URL");
    }
    
    const DOCS = {
        thematic: {
            name: "By Theme",
            url: "https://docs.google.com/document/d/e/2PACX-1vS9iILd7_1PfEdN8Gd-A1c7qOy7aZu_4Otg7gXDlxZnP0ZoXgRilCqsrud_gHBEkAydwSZG7H7wcUEC/pub"
        },
        chronological: {
            name: "Chronological Order",
            url: "https://docs.google.com/document/d/e/2PACX-1vT7b3MavM9VAIHpjQNG3Bj79BfCSnVbu4ucrQnjWyFAqVqYd-MOr8WsEfJ0x3x7OrsIAP4aA_UVLbeD/pub"
        }
    };
    
    let currentDoc = 'thematic'; // default

    let lectures = {};
    let allItems = {};
    let pool = [];
    let current = null;
    let state = "idle"; // "idle", "question", "answer"

    const statusEl = document.getElementById("status");
    const lecturesEl = document.getElementById("lectures");
    const startBtn = document.getElementById("startBtn");
    const cardEl = document.getElementById("card");
    const cardHintEl = document.getElementById("cardHint");
    const questionEl = document.getElementById("question");
    const answerEl = document.getElementById("answer");
    const modeLabelEl = document.getElementById("modeLabel");

    async function fetchDocText(url) {
        const EXPORT_URL = normalizeGoogleDocUrl(url);
        const res = await fetch(EXPORT_URL);
        if (!res.ok) {
            throw new Error("HTTP " + res.status);
        }
    
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, "text/html");
    
        // Extract raw text from body
        let text = doc.body.textContent || "";
        
        // Remove CSS and metadata
        text = text.replace(/\{[^}]*\}/g, '');
        text = text.replace(/^.*?Updated automatically every \d+ minutes/i, '');
        text = text.replace(/^.*?Title\s*/i, '');
        
        // Normalize whitespace but preserve structure
        text = text.replace(/\s+/g, ' ').trim();
        
        dbg("raw text length", text.length);
        
        const lines = [];
        
        // Split the text into sections by Lezione
        const sections = text.split(/(Lezione\s+\d+[^◊ê-◊™]*)/gi);
        
        dbg("sections found", sections.length);
        
        for (let i = 0; i < sections.length; i++) {
            const section = sections[i].trim();
            
            // If this is a Lezione header
            if (/^Lezione\s+\d+/i.test(section)) {
                lines.push(section);
            } else if (section.length > 0) {
                // Split on Hebrew characters (each vocab entry starts with Hebrew)
                // Look for pattern: Hebrew chars followed by dash
                const entries = section.split(/(?=[◊ê-◊™]{2,}\s*[‚Äì‚Äî-])/);
                
                entries.forEach(entry => {
                    const cleaned = entry.trim();
                    // Must contain Hebrew and at least one dash
                    if (cleaned && /[◊ê-◊™]/.test(cleaned) && /[‚Äì‚Äî-]/.test(cleaned)) {
                        lines.push(cleaned);
                    }
                });
            }
        }
        
        const result = lines.join('\n');
        dbg("normalized text preview", result.slice(0, 800));
        dbg("total lines after split", lines.length);
    
        return result;
    }

function parseLectures(text) {
    const lectures = {};
    let currentKey = null;
    let awaitingTitle = false;

    const lines = text.split(/\r?\n/);
    dbg("total lines", lines.length);

    lines.forEach((raw, index) => {
        const line = raw
            .replace(/^\uFEFF/, "")
            .replace(/[\u00A0\u200B\u200C\u200D]/g, " ")
            .replace(/\s+/g, " ")
            .trim();

        if (!line) return;

        if (line.toLowerCase().includes("lezione")) {
            dbg(`line ${index} contains 'Lezione'`, line);
        }

        if (/^Lezione\s+\d+/i.test(line)) {
            dbg(`LECTURE DETECTED at line ${index}`, line);

            currentKey = line.split(/[‚Äì‚Äî-]/)[0].trim();
            const titlePart = line.substring(currentKey.length).replace(/^[‚Äì‚Äî-]\s*/, '').trim();
            
            lectures[currentKey] = {
                name: currentKey,
                title: titlePart || "",
                lines: []
            };
            awaitingTitle = false;
            return;
        }

        if (currentKey) {
            lectures[currentKey].lines.push(line);
        }
    });

    dbg("parsed lectures object", lectures);
    dbg("lecture count", Object.keys(lectures).length);

    return lectures;
}

function extractItems(lines) {
    const items = [];

    dbg("extractItems called with", lines.length);

    for (const rawLine of lines) {
        const normalized = rawLine.replace(/[‚Äì‚Äî]/g, "-");
        const parts = normalized.split(/\s*-\s*/).map(p => p.trim()).filter(p => p.length > 0);

        // Need at least Hebrew and English (transliteration is optional)
        if (parts.length >= 2) {
            const heb = parts[0];
            const eng = parts[1];
            const trans = parts.length >= 3 ? parts.slice(2).join(" - ") : parts[1]; // Use English as fallback if no transliteration

            // Must have Hebrew characters in first part and some English in second
            if (heb && eng && /[◊ê-◊™]/.test(heb)) {
                items.push({ heb, eng, trans });
                dbg("extracted item", { heb, eng, trans });
            }
        }
    }

    dbg("items extracted", items.length);
    return items;
}

function buildLectureChips(lecturesMap) {
    dbg("buildLectureChips called with", Object.keys(lecturesMap));
    lecturesEl.innerHTML = "";

    const names = Object.keys(lecturesMap).sort((a, b) => {
        const na = parseInt(a.replace(/\D+/g, ""), 10);
        const nb = parseInt(b.replace(/\D+/g, ""), 10);
        return na - nb;
    });

    names.forEach(name => {
        const data = lecturesMap[name];
        dbg("rendering lecture chip", data);

        const chip = document.createElement("label");
        chip.className = "lecture-chip";

        const input = document.createElement("input");
        input.type = "checkbox";
        input.value = name;

        const text = document.createElement("span");
        text.innerHTML = data.title
            ? `<strong>${data.name}</strong><br><span style="font-size:0.75rem;opacity:.8">${data.title}</span>`
            : data.name;

        chip.appendChild(input);
        chip.appendChild(text);

        chip.addEventListener("click", e => {
            if (e.target.tagName !== "INPUT") {
                input.checked = !input.checked;
            }
            chip.classList.toggle("selected", input.checked);
            e.preventDefault();
        });

        lecturesEl.appendChild(chip);
    });

    statusEl.textContent = "Lectures loaded. Select one or more and press Start.";
    startBtn.disabled = false;
}


    function collectSelectedItems() {
        const checkboxes = lecturesEl.querySelectorAll("input[type=checkbox]");
        const chosen = [];
        checkboxes.forEach(cb => {
            if (cb.checked) {
                chosen.push(cb.value);
            }
        });

        const result = [];
        chosen.forEach(name => {
            if (allItems[name]) {
                result.push(...allItems[name]);
            }
        });
        return result;
    }

    function speakHebrew(text) {
        // Check if speech synthesis is supported
        if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'he-IL'; // Hebrew
            utterance.rate = 0.8; // Slightly slower for learning
            window.speechSynthesis.cancel(); // Cancel any ongoing speech
            window.speechSynthesis.speak(utterance);
        }
    }
    
    // Make it globally accessible for onclick handlers
    window.speakHebrew = speakHebrew;

    function nextCard() {
        const availableItems = collectSelectedItems();
        
        if (!availableItems.length) {
            questionEl.textContent = "";
            answerEl.textContent = "";
            cardHintEl.textContent = "Select at least one lecture and press Start.";
            state = "idle";
            return;
        }

        // Always pick randomly from all available items
        current = availableItems[Math.floor(Math.random() * availableItems.length)];
        const mode = Math.random() < 0.5 ? "heb_to_eng" : "eng_to_heb";

        answerEl.textContent = "";
        cardHintEl.textContent = "Tap to reveal answer. üîä Tap Hebrew text to hear pronunciation.";
        state = "question";

        if (mode === "heb_to_eng") {
            questionEl.innerHTML = `<span class="hebrew-audio" onclick="speakHebrew('${current.heb.replace(/'/g, "\\'")}'); event.stopPropagation();">${current.heb}</span>   (${current.trans})`;
            modeLabelEl.textContent = "Translate to English.";
            current.mode = mode;
            // Auto-play on question show
            setTimeout(() => speakHebrew(current.heb), 300);
        } else {
            questionEl.textContent = current.eng;
            modeLabelEl.textContent = "Translate to Hebrew.";
            current.mode = mode;
        }
    }

    function showAnswer() {
        if (!current) return;

        if (current.mode === "heb_to_eng") {
            answerEl.textContent = `${current.eng} ‚Äì ${current.trans}`;
        } else {
            answerEl.innerHTML = `<span class="hebrew-audio" onclick="speakHebrew('${current.heb.replace(/'/g, "\\'")}'); event.stopPropagation();">${current.heb}</span>   (${current.trans})`;
            // Auto-play the Hebrew pronunciation when showing answer
            setTimeout(() => speakHebrew(current.heb), 200);
        }
        cardHintEl.textContent = "Tap for next word. üîä Tap Hebrew text to hear again.";
        state = "answer";
    }

    startBtn.addEventListener("click", () => {
        const items = collectSelectedItems();
        if (!items.length) {
            alert("Select at least one lecture.");
            return;
        }
        nextCard();
    });

    cardEl.addEventListener("click", () => {
        if (state === "question") {
            showAnswer();
        } else if (state === "answer") {
            nextCard();
        }
    });

(async function init() {
    try {
        dbg("init started", true);
        await loadDocument(currentDoc);
    } catch (e) {
        console.error(e);
        statusEl.textContent = "Error loading document: " + e.message;
    }
})();

async function loadDocument(docKey) {
    try {
        statusEl.textContent = `Loading ${DOCS[docKey].name}...`;
        startBtn.disabled = true;
        
        const text = await fetchDocText(DOCS[docKey].url);
        lectures = parseLectures(text);

        dbg("lectures after parse", lectures);

        const itemsMap = {};
        Object.keys(lectures).forEach(name => {
            itemsMap[name] = extractItems(lectures[name].lines);
        });

        allItems = itemsMap;
        dbg("allItems", allItems);

        buildLectureChips(lectures);
        
        // Reset card state
        state = "idle";
        pool = [];
        questionEl.textContent = "";
        answerEl.textContent = "";
        cardHintEl.textContent = "Choose lectures and press Start.";
        modeLabelEl.textContent = "";
    } catch (e) {
        console.error(e);
        statusEl.textContent = "Error loading document: " + e.message;
    }
}

// Document selector event listeners
document.querySelectorAll('.doc-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
        const docKey = btn.dataset.doc;
        if (docKey === currentDoc) return;
        
        // Update UI
        document.querySelectorAll('.doc-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Load new document
        currentDoc = docKey;
        await loadDocument(docKey);
    });
});
</script>
</body>
</html>
