<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hebrew Flashcards</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            background: #111;
            color: #f5f5f5;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            padding: 1rem 1.2rem;
            text-align: center;
            font-size: 1.1rem;
            background: #181818;
            border-bottom: 1px solid #333;
        }
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0.8rem 1.2rem 1.2rem;
            gap: 0.8rem;
        }
        #status {
            font-size: 0.9rem;
            color: #bbb;
        }
        #docSelector {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }
        .doc-btn {
            padding: 0.4rem 0.8rem;
            border-radius: 999px;
            border: 1px solid #444;
            background: transparent;
            color: #bbb;
            font-size: 0.85rem;
            cursor: pointer;
            font-weight: 400;
        }
        .doc-btn.active {
            background: #2e7dff;
            border-color: #2e7dff;
            color: #fff;
            font-weight: 500;
        }
        #lectures {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.2rem;
        }
        .lecture-chip {
            padding: 0.3rem 0.7rem;
            border-radius: 999px;
            border: 1px solid #444;
            font-size: 0.85rem;
            cursor: pointer;
            user-select: none;
            line-height: 1.2;
            text-align: left;

        }
        .lecture-chip input {
            display: none;
        }
        .lecture-chip.selected {
            background: #2e7dff;
            border-color: #2e7dff;
            color: #fff;
        }
        #controls {
            display: flex;
            gap: 0.6rem;
            align-items: center;
            margin-top: 0.4rem;
        }
        button {
            padding: 0.5rem 0.9rem;
            border-radius: 999px;
            border: none;
            background: #2e7dff;
            color: #fff;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
        }
        button:disabled {
            opacity: 0.5;
            cursor: default;
        }
        #modeLabel {
            font-size: 0.85rem;
            color: #bbb;
        }
        #card {
            margin-top: 0.8rem;
            flex: 1;
            border-radius: 1rem;
            border: 1px solid #333;
            background: #181818;
            padding: 1.2rem 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            user-select: none;
            transition: transform 0.2s ease;
            touch-action: pan-y;
            transform-style: preserve-3d;
        }
        #card.flip {
            animation: quickFlip 0.3s ease;
        }
        @keyframes quickFlip {
            0% { transform: rotateY(0deg); }
            50% { transform: rotateY(90deg); }
            100% { transform: rotateY(0deg); }
        }
        #card.swipe-left {
            transform: translateX(-100px) rotate(-5deg);
            opacity: 0.5;
        }
        #card.swipe-right {
            transform: translateX(100px) rotate(5deg);
            opacity: 0.5;
        }
        #multipleChoiceOptions {
            display: none;
            flex-direction: column;
            gap: 0.8rem;
            margin-top: 1rem;
        }
        #multipleChoiceOptions.show {
            display: flex;
        }
        .mc-option {
            padding: 1rem;
            border-radius: 0.8rem;
            border: 2px solid #333;
            background: #222;
            color: #fff;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }
        .mc-option:hover {
            border-color: #2e7dff;
            background: #2a2a2a;
        }
        .mc-option.correct {
            border-color: #22c55e;
            background: #1a4d2e;
        }
        .mc-option.incorrect {
            border-color: #ef4444;
            background: #4d1a1a;
        }
        #difficultyButtons {
            display: none;
            gap: 0.5rem;
            margin-top: 1rem;
            justify-content: center;
        }
        #difficultyButtons.show {
            display: flex;
        }
        .diff-btn {
            padding: 0.5rem 1rem;
            border-radius: 999px;
            border: none;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }
        .diff-btn.easy {
            background: #22c55e;
            color: white;
        }
        .diff-btn.medium {
            background: #eab308;
            color: white;
        }
        .diff-btn.hard {
            background: #ef4444;
            color: white;
        }
        .diff-btn:hover {
            transform: scale(1.05);
            filter: brightness(1.1);
        }
        #statsPanel {
            background: #181818;
            border: 1px solid #333;
            border-radius: 0.8rem;
            padding: 0.8rem;
            margin-top: 0.8rem;
            display: none;
            gap: 1rem;
        }
        #statsPanel.show {
            display: flex;
        }
        .stat-item {
            flex: 1;
            text-align: center;
        }
        .stat-value {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2e7dff;
        }
        .stat-label {
            font-size: 0.75rem;
            color: #888;
            margin-top: 0.2rem;
        }
        #quickActions {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
            margin-top: 0.5rem;
        }
        .quick-btn {
            padding: 0.35rem 0.7rem;
            border-radius: 999px;
            border: 1px solid #444;
            background: transparent;
            color: #bbb;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }
        .quick-btn:hover {
            background: #2e7dff;
            border-color: #2e7dff;
            color: #fff;
        }
        .quick-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        #cardHint {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 0.6rem;
        }
        #question {
            font-size: 1.4rem;
            margin-bottom: 0.6rem;
            line-height: 1.3;
        }
        .hebrew-audio {
            cursor: pointer;
            text-decoration: underline;
            text-decoration-style: dotted;
            text-decoration-color: #666;
            transition: all 0.2s;
        }
        .hebrew-audio:hover {
            color: #2e7dff;
            text-decoration-color: #2e7dff;
        }
        #answer {
            font-size: 1rem;
            color: #ddd;
            min-height: 1.2em;
            line-height: 1.4;
        }
        #footer {
            font-size: 0.8rem;
            color: #777;
            text-align: center;
            padding: 0.4rem 0.8rem 0.8rem;
        }
    </style>
</head>
<body>
<header>
    Hebrew Flashcards
</header>
<main>
    <div id="status">Loading words from Google Doc‚Ä¶</div>

    <div id="docSelector">
        <button class="doc-btn active" data-doc="thematic">By Theme</button>
        <button class="doc-btn" data-doc="chronological">Chronological</button>
    </div>

    <div id="quickActions">
        <button class="quick-btn" id="selectAllBtn">Select All</button>
        <button class="quick-btn" id="clearAllBtn">Clear All</button>
        <button class="quick-btn" id="studyUnlearnedBtn">Study Unlearned</button>
        <button class="quick-btn" id="reviewDifficultBtn">Review Difficult</button>
        <button class="quick-btn" id="reviewSessionBtn">üìù Review Session</button>
        <button class="quick-btn" id="suggestLectureBtn">üí° Suggest Next</button>
        <button class="quick-btn" id="syncBtn">‚òÅÔ∏è Sync Now</button>
    </div>

    <div id="studyMode" style="margin-top: 0.8rem; display: flex; gap: 0.5rem; align-items: center;">
        <span style="font-size: 0.85rem; color: #888;">Mode:</span>
        <select id="modeSelector" style="padding: 0.4rem 0.8rem; border-radius: 999px; border: 1px solid #444; background: #222; color: #fff; font-size: 0.85rem; cursor: pointer;">
            <option value="flashcard">Flashcard</option>
            <option value="multiple-choice">Multiple Choice</option>
            <option value="typing">Type Answer</option>
        </select>
    </div>

    <div id="topDifficult" style="margin-top: 0.8rem; padding: 0.8rem; background: #181818; border: 1px solid #333; border-radius: 0.8rem; display: none;">
        <div style="font-size: 0.9rem; font-weight: 600; margin-bottom: 0.5rem; color: #ef4444;">üî• Top 10 Most Difficult Words</div>
        <div id="difficultWordsList" style="font-size: 0.85rem; color: #bbb;"></div>
    </div>

    <div id="lectures"></div>

    <div id="statsPanel">
        <div class="stat-item">
            <div class="stat-value" id="statStudied">0</div>
            <div class="stat-label">Studied</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="statAccuracy">-</div>
            <div class="stat-label">Accuracy</div>
        </div>
        <div class="stat-item">
            <div class="stat-value" id="statStreak">0</div>
            <div class="stat-label">Day Streak</div>
        </div>
    </div>

    <div id="controls">
        <button id="startBtn" disabled>Start</button>
        <div id="modeLabel"></div>
    </div>

    <div id="card">
        <div id="cardHint">Choose lectures and press Start.</div>
        <div id="question"></div>
        <div id="answer"></div>
        <div id="multipleChoiceOptions"></div>
    </div>

    <div id="difficultyButtons">
        <button class="diff-btn easy" data-difficulty="easy">Easy (1)</button>
        <button class="diff-btn medium" data-difficulty="medium">Medium (2)</button>
        <button class="diff-btn hard" data-difficulty="hard">Hard (3)</button>
    </div>
</main>
<div id="footer">
    Tap card to reveal/next ‚Ä¢ Keyboard: Space=reveal, Enter=next, 1/2/3=rate difficulty, R=replay audio
</div>

<script>

    function dbg(label, value) {
    console.log(`[DEBUG] ${label}:`, value);
    }


    async function fetchDocText() {
        const res = await fetch(DOC_URL);
        if (!res.ok) {
            throw new Error("HTTP " + res.status);
        }
    
        const csvText = await res.text();
        dbg("CSV text preview", csvText.slice(0, 500));
        
        return csvText;
    }

    function parseLectures(csvText, viewMode = 'thematic') {
        const lectures = {};
        const lines = csvText.split(/\r?\n/);
        
        dbg("total CSV lines", lines.length);
        dbg("view mode", viewMode);
        
        let isHeader = true;
        
        lines.forEach((line, index) => {
            // Skip empty lines
            if (!line.trim()) return;
            
            // Skip header row
            if (isHeader) {
                isHeader = false;
                dbg("Skipping header row:", line);
                return;
            }
            
            // Parse CSV - handle quoted fields properly
            const parts = [];
            let current = '';
            let inQuotes = false;
            
            for (let i = 0; i < line.length; i++) {
                const char = line[i];
                if (char === '"') {
                    inQuotes = !inQuotes;
                } else if (char === ',' && !inQuotes) {
                    parts.push(current.trim());
                    current = '';
                } else {
                    current += char;
                }
            }
            parts.push(current.trim());
            
            // CSV columns: Parola in Ebraico, Traduzione, Traslitterazione, Area Tematica, Cronologia
            const heb = parts[0] || '';
            const eng = parts[1] || '';
            const trans = parts[2] || '';
            const areaTematica = parts[3] || '';
            const cronologia = parts[4] || '';
            
            // Skip if no Hebrew word
            if (!heb || !/[◊ê-◊™]/.test(heb)) return;
            
            const entry = `${heb} ‚Äì ${eng} ‚Äì ${trans}`;
            
            if (viewMode === 'thematic') {
                // Use Area Tematica as lecture name
                if (areaTematica) {
                    const lectureName = areaTematica;
                    
                    if (!lectures[lectureName]) {
                        lectures[lectureName] = {
                            name: lectureName,
                            title: '',
                            lines: []
                        };
                        dbg(`Created thematic lecture: ${lectureName}`);
                    }
                    
                    lectures[lectureName].lines.push(entry);
                }
            } else if (viewMode === 'chronological') {
                // Use Cronologia as lecture name
                if (cronologia) {
                    const lectureName = cronologia;
                    
                    if (!lectures[lectureName]) {
                        lectures[lectureName] = {
                            name: lectureName,
                            title: '',
                            lines: []
                        };
                        dbg(`Created chronological lecture: ${lectureName}`);
                    }
                    
                    lectures[lectureName].lines.push(entry);
                }
            }
        });

        dbg("parsed lectures object", lectures);
        dbg("lecture count", Object.keys(lectures).length);

        return lectures;
    }

    function extractItems(lines) {
        const items = [];

        dbg("extractItems called with", lines.length);

        for (const rawLine of lines) {
            const normalized = rawLine.replace(/[‚Äì‚Äî]/g, "-");
            const parts = normalized.split(/\s*-\s*/).map(p => p.trim()).filter(p => p.length > 0);

            if (parts.length >= 2) {
                const heb = parts[0];
                const eng = parts[1];
                const trans = parts.length >= 3 ? parts.slice(2).join(" - ") : parts[1];

                if (heb && eng && /[◊ê-◊™]/.test(heb)) {
                    items.push({ heb, eng, trans });
                    dbg("extracted item", { heb, eng, trans });
                }
            }
        }

        dbg("items extracted", items.length);
        return items;
    }
    
    const DOC_URL = "https://docs.google.com/spreadsheets/d/e/2PACX-1vSZ7JnAurRzW2CdTYdObIOhArDnssT1x7erlUrXZx4XzFLK-D-fV6S209nZVEz-7L1Fa43vtZyuSyQf/pub?output=csv";
    const PROGRESS_API_URL = "https://script.google.com/macros/s/AKfycbzixsucigGRd0uCEezZn_bUaAV9wbCffhr5L720YVksD8Ah8Co91xh26NKkqjCyhG4B/exec";
    
    let currentView = 'thematic'; // 'thematic' or 'chronological'
    let isSyncing = false;
    let studyMode = 'flashcard'; // 'flashcard', 'multiple-choice', 'typing'

    let lectures = {};
    let allItems = {};
    let pool = [];
    let current = null;
    let state = "idle"; // "idle", "question", "answer"
    let multipleChoiceCorrectAnswer = null;
    
    // Progress tracking
    let progress = {
        learned: {}, // {word_hash: {difficulty, lastSeen, timesReviewed, correct, incorrect}}
        stats: {
            todayStudied: 0,
            totalStudied: 0,
            lastStudyDate: null,
            streak: 0,
            sessionCorrect: 0,
            sessionIncorrect: 0,
            sessionTotal: 0
        }
    };
    
    // Touch/swipe handling
    let touchStartX = 0;
    let touchStartY = 0;
    let touchEndX = 0;
    let touchEndY = 0;

    const statusEl = document.getElementById("status");
    const lecturesEl = document.getElementById("lectures");
    const startBtn = document.getElementById("startBtn");
    const cardEl = document.getElementById("card");
    const cardHintEl = document.getElementById("cardHint");
    const questionEl = document.getElementById("question");
    const answerEl = document.getElementById("answer");
    const modeLabelEl = document.getElementById("modeLabel");
    const difficultyButtonsEl = document.getElementById("difficultyButtons");
    const statsPanelEl = document.getElementById("statsPanel");
    
    // Load progress from cloud (with localStorage fallback)
    async function loadProgress() {
        try {
            statusEl.textContent = 'Loading your progress from cloud...';
            
            const response = await fetch(`${PROGRESS_API_URL}?action=load`);
            const cloudProgress = await response.json();
            
            if (cloudProgress && !cloudProgress.error) {
                progress = cloudProgress;
                updateDailyStats();
                updateStatsDisplay();
                
                // Also save to localStorage as backup
                localStorage.setItem('hebrewFlashcardsProgress', JSON.stringify(progress));
                
                dbg('Progress loaded from cloud', progress);
                statusEl.textContent = 'Progress loaded from cloud ‚úì';
            } else {
                throw new Error(cloudProgress.error || 'Failed to load from cloud');
            }
        } catch (e) {
            console.error('Cloud load failed, using localStorage:', e);
            statusEl.textContent = 'Using local progress (cloud unavailable)';
            
            // Fallback to localStorage
            const saved = localStorage.getItem('hebrewFlashcardsProgress');
            if (saved) {
                try {
                    progress = JSON.parse(saved);
                    updateDailyStats();
                    updateStatsDisplay();
                } catch (e) {
                    console.error('Error loading from localStorage:', e);
                }
            }
        }
    }
    
    async function saveProgress() {
        // Always save to localStorage immediately
        localStorage.setItem('hebrewFlashcardsProgress', JSON.stringify(progress));
        
        // Debounced cloud save
        if (isSyncing) return;
        
        isSyncing = true;
        
        // Wait a bit to batch multiple saves
        setTimeout(async () => {
            try {
                const response = await fetch(`${PROGRESS_API_URL}?action=save`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(progress)
                });
                
                const result = await response.json();
                
                if (result.success) {
                    dbg('Progress saved to cloud', true);
                    // Show subtle indicator
                    const originalText = statusEl.textContent;
                    statusEl.textContent = '‚òÅÔ∏è Synced';
                    setTimeout(() => {
                        if (statusEl.textContent === '‚òÅÔ∏è Synced') {
                            statusEl.textContent = originalText;
                        }
                    }, 2000);
                } else {
                    console.error('Cloud save failed:', result.error);
                }
            } catch (e) {
                console.error('Error saving to cloud:', e);
            } finally {
                isSyncing = false;
            }
        }, 1000); // 1 second debounce
    }
    
    function updateDailyStats() {
        const today = new Date().toDateString();
        if (progress.stats.lastStudyDate !== today) {
            // New day
            if (progress.stats.lastStudyDate) {
                const lastDate = new Date(progress.stats.lastStudyDate);
                const todayDate = new Date(today);
                const diffDays = Math.floor((todayDate - lastDate) / (1000 * 60 * 60 * 24));
                
                if (diffDays === 1) {
                    progress.stats.streak++;
                } else if (diffDays > 1) {
                    progress.stats.streak = 1;
                }
            } else {
                progress.stats.streak = 1;
            }
            
            progress.stats.todayStudied = 0;
            progress.stats.lastStudyDate = today;
            progress.stats.sessionCorrect = 0;
            progress.stats.sessionIncorrect = 0;
            progress.stats.sessionTotal = 0;
        }
    }
    
    function updateStatsDisplay() {
        document.getElementById('statStudied').textContent = progress.stats.sessionTotal;
        
        const accuracy = progress.stats.sessionTotal > 0 
            ? Math.round((progress.stats.sessionCorrect / progress.stats.sessionTotal) * 100)
            : 0;
        document.getElementById('statAccuracy').textContent = progress.stats.sessionTotal > 0 ? accuracy + '%' : '-';
        
        document.getElementById('statStreak').textContent = progress.stats.streak;
        
        // Update top difficult words
        updateTopDifficultWords();
    }
    
    function updateTopDifficultWords() {
        const difficultWords = [];
        
        for (const [hash, data] of Object.entries(progress.learned)) {
            if (data.difficulty === 'hard' || (data.incorrect > data.correct)) {
                const [heb, eng] = hash.split('::');
                const errorRate = data.timesReviewed > 0 ? data.incorrect / data.timesReviewed : 0;
                difficultWords.push({ heb, eng, errorRate, incorrect: data.incorrect, reviewed: data.timesReviewed });
            }
        }
        
        // Sort by error rate, then by number of incorrect
        difficultWords.sort((a, b) => b.errorRate - a.errorRate || b.incorrect - a.incorrect);
        
        const top10 = difficultWords.slice(0, 10);
        
        if (top10.length > 0) {
            document.getElementById('topDifficult').style.display = 'block';
            const html = top10.map((w, i) => 
                `<div style="padding: 0.3rem 0; border-bottom: 1px solid #2a2a2a;">
                    ${i + 1}. <strong>${w.heb}</strong> - ${w.eng} 
                    <span style="color: #ef4444;">(${w.incorrect}/${w.reviewed} wrong)</span>
                </div>`
            ).join('');
            document.getElementById('difficultWordsList').innerHTML = html;
        } else {
            document.getElementById('topDifficult').style.display = 'none';
        }
    }
    
    function suggestNextLecture() {
        const suggestions = [];
        
        for (const [name, items] of Object.entries(allItems)) {
            const totalWords = items.length;
            let learnedCount = 0;
            let avgDifficulty = 0;
            let difficultySum = 0;
            let difficultyCount = 0;
            
            items.forEach(item => {
                const hash = getWordHash(item);
                if (progress.learned[hash]) {
                    learnedCount++;
                    if (progress.learned[hash].difficulty === 'easy') {
                        difficultySum += 1;
                    } else if (progress.learned[hash].difficulty === 'medium') {
                        difficultySum += 2;
                    } else if (progress.learned[hash].difficulty === 'hard') {
                        difficultySum += 3;
                    }
                    difficultyCount++;
                }
            });
            
            const completionRate = learnedCount / totalWords;
            avgDifficulty = difficultyCount > 0 ? difficultySum / difficultyCount : 0;
            
            // Score: prioritize partially completed, not too difficult lectures
            const score = completionRate * 0.5 + (1 - avgDifficulty / 3) * 0.3 + (learnedCount > 0 ? 0.2 : 0);
            
            suggestions.push({
                name,
                completionRate,
                avgDifficulty,
                score,
                learned: learnedCount,
                total: totalWords
            });
        }
        
        suggestions.sort((a, b) => b.score - a.score);
        
        const best = suggestions[0];
        if (best) {
            const msg = `Suggested: "${best.name}"\n\n` +
                       `Progress: ${best.learned}/${best.total} words (${Math.round(best.completionRate * 100)}%)\n` +
                       `Would you like to select it?`;
            
            if (confirm(msg)) {
                // Select this lecture
                lecturesEl.querySelectorAll('input[type=checkbox]').forEach(cb => {
                    cb.checked = cb.value === best.name;
                    cb.parentElement.classList.toggle('selected', cb.checked);
                });
            }
        }
    }
    
    function getWordHash(word) {
        // Simple hash for tracking words
        return word.heb + '::' + word.eng;
    }
    
    function recordDifficulty(difficulty) {
        if (!current) return;
        
        const hash = getWordHash(current);
        const now = Date.now();
        
        if (!progress.learned[hash]) {
            progress.learned[hash] = {
                difficulty: difficulty,
                lastSeen: now,
                timesReviewed: 1,
                correct: difficulty === 'easy' ? 1 : 0,
                incorrect: difficulty === 'hard' ? 1 : 0
            };
        } else {
            progress.learned[hash].difficulty = difficulty;
            progress.learned[hash].lastSeen = now;
            progress.learned[hash].timesReviewed++;
            
            if (difficulty === 'easy') {
                progress.learned[hash].correct++;
            } else if (difficulty === 'hard') {
                progress.learned[hash].incorrect++;
            }
        }
        
        // Update session stats
        progress.stats.sessionTotal++;
        progress.stats.todayStudied++;
        progress.stats.totalStudied++;
        
        if (difficulty === 'easy' || difficulty === 'medium') {
            progress.stats.sessionCorrect++;
        } else {
            progress.stats.sessionIncorrect++;
        }
        
        updateDailyStats();
        saveProgress();
        updateStatsDisplay();
    }

function buildLectureChips(lecturesMap) {
    dbg("buildLectureChips called with", Object.keys(lecturesMap));
    lecturesEl.innerHTML = "";

    const names = Object.keys(lecturesMap).sort((a, b) => {
        const na = parseInt(a.replace(/\D+/g, ""), 10);
        const nb = parseInt(b.replace(/\D+/g, ""), 10);
        return na - nb;
    });

    names.forEach(name => {
        const data = lecturesMap[name];
        dbg("rendering lecture chip", data);

        const chip = document.createElement("label");
        chip.className = "lecture-chip";

        const input = document.createElement("input");
        input.type = "checkbox";
        input.value = name;

        const text = document.createElement("span");
        text.innerHTML = data.title
            ? `<strong>${data.name}</strong><br><span style="font-size:0.75rem;opacity:.8">${data.title}</span>`
            : data.name;

        chip.appendChild(input);
        chip.appendChild(text);

        chip.addEventListener("click", e => {
            if (e.target.tagName !== "INPUT") {
                input.checked = !input.checked;
            }
            chip.classList.toggle("selected", input.checked);
            e.preventDefault();
        });

        lecturesEl.appendChild(chip);
    });

    statusEl.textContent = "Lectures loaded. Select one or more and press Start.";
    startBtn.disabled = false;
}


    function collectSelectedItems() {
        const checkboxes = lecturesEl.querySelectorAll("input[type=checkbox]");
        const chosen = [];
        checkboxes.forEach(cb => {
            if (cb.checked) {
                chosen.push(cb.value);
            }
        });

        const result = [];
        chosen.forEach(name => {
            if (allItems[name]) {
                result.push(...allItems[name]);
            }
        });
        return result;
    }

    function speakHebrew(text) {
        // Check if speech synthesis is supported
        if ('speechSynthesis' in window) {
            const utterance = new SpeechSynthesisUtterance(text);
            utterance.lang = 'he-IL'; // Hebrew
            utterance.rate = 0.8; // Slightly slower for learning
            window.speechSynthesis.cancel(); // Cancel any ongoing speech
            window.speechSynthesis.speak(utterance);
        }
    }
    
    // Make it globally accessible for onclick handlers
    window.speakHebrew = speakHebrew;

    function nextCard() {
        const availableItems = collectSelectedItems();
        
        if (!availableItems.length) {
            questionEl.textContent = "";
            answerEl.textContent = "";
            cardHintEl.textContent = "Select at least one lecture and press Start.";
            state = "idle";
            difficultyButtonsEl.classList.remove('show');
            document.getElementById('multipleChoiceOptions').classList.remove('show');
            return;
        }

        // Hide UI elements
        difficultyButtonsEl.classList.remove('show');
        document.getElementById('multipleChoiceOptions').classList.remove('show');
        answerEl.textContent = "";
        
        // Reset and trigger flip animation
        cardEl.classList.remove('swipe-left', 'swipe-right', 'flip');
        setTimeout(() => cardEl.classList.add('flip'), 10);

        // Weighted random selection
        let weightedItems = [];
        availableItems.forEach(item => {
            const hash = getWordHash(item);
            const learned = progress.learned[hash];
            
            if (!learned) {
                weightedItems.push(item);
            } else if (learned.difficulty === 'hard') {
                weightedItems.push(item, item, item);
            } else if (learned.difficulty === 'medium') {
                weightedItems.push(item, item);
            } else {
                weightedItems.push(item);
            }
        });
        
        current = weightedItems[Math.floor(Math.random() * weightedItems.length)];
        const mode = Math.random() < 0.5 ? "heb_to_eng" : "eng_to_heb";
        current.mode = mode;
        
        state = "question";

        // Handle different study modes
        if (studyMode === 'multiple-choice') {
            showMultipleChoice();
        } else if (studyMode === 'typing') {
            showTypingMode();
        } else {
            // Standard flashcard mode
            showFlashcardQuestion();
        }
    }
    
    function showFlashcardQuestion() {
        answerEl.textContent = "";
        cardHintEl.textContent = "Tap to reveal answer. üîä Tap Hebrew text to hear pronunciation.";

        if (current.mode === "heb_to_eng") {
            questionEl.innerHTML = `<span class="hebrew-audio" onclick="speakHebrew('${current.heb.replace(/'/g, "\\'")}'); event.stopPropagation();">${current.heb}</span>   (${current.trans})`;
            modeLabelEl.textContent = "Translate to English.";
            setTimeout(() => speakHebrew(current.heb), 300);
        } else {
            questionEl.textContent = current.eng;
            modeLabelEl.textContent = "Translate to Hebrew.";
        }
    }
    
    function showMultipleChoice() {
        const mcOptions = document.getElementById('multipleChoiceOptions');
        mcOptions.innerHTML = '';
        mcOptions.classList.add('show');
        
        cardHintEl.textContent = "Select the correct answer";
        
        if (current.mode === "heb_to_eng") {
            questionEl.innerHTML = `<span class="hebrew-audio" onclick="speakHebrew('${current.heb.replace(/'/g, "\\'")}'); event.stopPropagation();">${current.heb}</span>   (${current.trans})`;
            modeLabelEl.textContent = "Select the English translation:";
            setTimeout(() => speakHebrew(current.heb), 300);
            
            // Generate wrong answers
            const allItems = collectSelectedItems();
            const wrongAnswers = allItems
                .filter(item => item.eng !== current.eng)
                .sort(() => Math.random() - 0.5)
                .slice(0, 3)
                .map(item => item.eng);
            
            const options = [...wrongAnswers, current.eng].sort(() => Math.random() - 0.5);
            multipleChoiceCorrectAnswer = current.eng;
            
            options.forEach(option => {
                const btn = document.createElement('div');
                btn.className = 'mc-option';
                btn.textContent = option;
                btn.onclick = () => checkMultipleChoice(btn, option);
                mcOptions.appendChild(btn);
            });
        } else {
            questionEl.textContent = current.eng;
            modeLabelEl.textContent = "Select the Hebrew translation:";
            
            const allItems = collectSelectedItems();
            const wrongAnswers = allItems
                .filter(item => item.heb !== current.heb)
                .sort(() => Math.random() - 0.5)
                .slice(0, 3)
                .map(item => `${item.heb} (${item.trans})`);
            
            const options = [...wrongAnswers, `${current.heb} (${current.trans})`].sort(() => Math.random() - 0.5);
            multipleChoiceCorrectAnswer = `${current.heb} (${current.trans})`;
            
            options.forEach(option => {
                const btn = document.createElement('div');
                btn.className = 'mc-option';
                btn.textContent = option;
                btn.onclick = () => checkMultipleChoice(btn, option);
                mcOptions.appendChild(btn);
            });
        }
    }
    
    function checkMultipleChoice(btn, answer) {
        const isCorrect = answer === multipleChoiceCorrectAnswer;
        
        btn.classList.add(isCorrect ? 'correct' : 'incorrect');
        
        // Disable all options
        document.querySelectorAll('.mc-option').forEach(opt => {
            opt.style.pointerEvents = 'none';
            if (opt.textContent === multipleChoiceCorrectAnswer) {
                opt.classList.add('correct');
            }
        });
        
        // Record result
        recordDifficulty(isCorrect ? 'easy' : 'hard');
        
        // Show answer
        if (current.mode === "heb_to_eng") {
            answerEl.textContent = `${current.eng} ‚Äì ${current.trans}`;
        } else {
            answerEl.innerHTML = `<span class="hebrew-audio" onclick="speakHebrew('${current.heb.replace(/'/g, "\\'")}'); event.stopPropagation();">${current.heb}</span>   (${current.trans})`;
            setTimeout(() => speakHebrew(current.heb), 200);
        }
        
        state = "answer";
        cardHintEl.textContent = "Tap card or press Enter for next word";
        
        // Auto-advance after 1.5 seconds
        setTimeout(() => {
            if (state === "answer") {
                nextCard();
            }
        }, 1500);
    }
    
    function showTypingMode() {
        cardHintEl.textContent = "Type your answer and press Enter";
        answerEl.innerHTML = '<input type="text" id="typingInput" style="width: 100%; padding: 0.8rem; font-size: 1rem; border-radius: 0.5rem; border: 2px solid #444; background: #222; color: #fff; text-align: center;" placeholder="Type answer here...">';
        
        if (current.mode === "heb_to_eng") {
            questionEl.innerHTML = `<span class="hebrew-audio" onclick="speakHebrew('${current.heb.replace(/'/g, "\\'")}'); event.stopPropagation();">${current.heb}</span>   (${current.trans})`;
            modeLabelEl.textContent = "Type the English translation:";
            setTimeout(() => speakHebrew(current.heb), 300);
        } else {
            questionEl.textContent = current.eng;
            modeLabelEl.textContent = "Type the Hebrew word:";
        }
        
        const input = document.getElementById('typingInput');
        input.focus();
        
        input.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') {
                checkTypingAnswer(input.value.trim());
            }
        });
    }
    
    function checkTypingAnswer(userAnswer) {
        const correctAnswer = current.mode === "heb_to_eng" ? current.eng.toLowerCase() : current.heb;
        const isCorrect = userAnswer.toLowerCase() === correctAnswer.toLowerCase();
        
        const input = document.getElementById('typingInput');
        input.disabled = true;
        input.style.borderColor = isCorrect ? '#22c55e' : '#ef4444';
        input.style.background = isCorrect ? '#1a4d2e' : '#4d1a1a';
        
        recordDifficulty(isCorrect ? 'easy' : 'hard');
        
        if (current.mode === "heb_to_eng") {
            answerEl.innerHTML = `<div style="margin-bottom: 0.5rem;">${input.outerHTML}</div><div>Correct: ${current.eng} ‚Äì ${current.trans}</div>`;
        } else {
            answerEl.innerHTML = `<div style="margin-bottom: 0.5rem;">${input.outerHTML}</div><div><span class="hebrew-audio" onclick="speakHebrew('${current.heb.replace(/'/g, "\\'")}'); event.stopPropagation();">${current.heb}</span>   (${current.trans})</div>`;
            setTimeout(() => speakHebrew(current.heb), 200);
        }
        
        state = "answer";
        cardHintEl.textContent = "Tap card or press Enter for next word";
        
        setTimeout(() => {
            if (state === "answer") {
                nextCard();
            }
        }, 1500);
    }

    function showAnswer() {
        if (!current) return;

        if (current.mode === "heb_to_eng") {
            answerEl.textContent = `${current.eng} ‚Äì ${current.trans}`;
        } else {
            answerEl.innerHTML = `<span class="hebrew-audio" onclick="speakHebrew('${current.heb.replace(/'/g, "\\'")}'); event.stopPropagation();">${current.heb}</span>   (${current.trans})`;
            // Auto-play the Hebrew pronunciation when showing answer
            setTimeout(() => speakHebrew(current.heb), 200);
        }
        cardHintEl.textContent = "Rate difficulty or tap for next. üîä Tap Hebrew to hear again.";
        state = "answer";
        
        // Show difficulty buttons
        difficultyButtonsEl.classList.add('show');
    }

    startBtn.addEventListener("click", () => {
        const items = collectSelectedItems();
        if (!items.length) {
            alert("Select at least one lecture.");
            return;
        }
        statsPanelEl.classList.add('show');
        nextCard();
    });

    cardEl.addEventListener("click", () => {
        // Don't handle clicks in multiple choice or typing mode
        if (studyMode === 'multiple-choice' || studyMode === 'typing') {
            if (state === "answer") {
                nextCard();
            }
            return;
        }
        
        // Standard flashcard mode
        if (state === "question") {
            showAnswer();
        } else if (state === "answer") {
            nextCard();
        }
    });
    
    // Difficulty button listeners
    document.querySelectorAll('.diff-btn').forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.stopPropagation();
            const difficulty = btn.dataset.difficulty;
            recordDifficulty(difficulty);
            nextCard();
        });
    });
    
    // Keyboard shortcuts
    document.addEventListener('keydown', (e) => {
        if (state === "idle") return;
        
        // Space = reveal answer
        if (e.code === 'Space' && state === "question") {
            e.preventDefault();
            showAnswer();
        }
        // Enter = next card
        else if (e.code === 'Enter' && state === "answer") {
            e.preventDefault();
            nextCard();
        }
        // 1 = Easy
        else if ((e.code === 'Digit1' || e.code === 'Numpad1') && state === "answer") {
            e.preventDefault();
            recordDifficulty('easy');
            nextCard();
        }
        // 2 = Medium
        else if ((e.code === 'Digit2' || e.code === 'Numpad2') && state === "answer") {
            e.preventDefault();
            recordDifficulty('medium');
            nextCard();
        }
        // 3 = Hard
        else if ((e.code === 'Digit3' || e.code === 'Numpad3') && state === "answer") {
            e.preventDefault();
            recordDifficulty('hard');
            nextCard();
        }
        // R = Replay audio
        else if (e.code === 'KeyR' && current) {
            e.preventDefault();
            speakHebrew(current.heb);
        }
    });
    
    // Touch/Swipe gestures for mobile
    cardEl.addEventListener('touchstart', (e) => {
        touchStartX = e.changedTouches[0].screenX;
        touchStartY = e.changedTouches[0].screenY;
    }, { passive: true });
    
    cardEl.addEventListener('touchmove', (e) => {
        touchEndX = e.changedTouches[0].screenX;
        touchEndY = e.changedTouches[0].screenY;
        
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        // Visual feedback during swipe
        if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 30) {
            if (deltaX > 0) {
                cardEl.style.transform = `translateX(${deltaX}px) rotate(${deltaX / 20}deg)`;
            } else {
                cardEl.style.transform = `translateX(${deltaX}px) rotate(${deltaX / 20}deg)`;
            }
        }
    }, { passive: true });
    
    cardEl.addEventListener('touchend', (e) => {
        const deltaX = touchEndX - touchStartX;
        const deltaY = touchEndY - touchStartY;
        
        // Reset transform
        cardEl.style.transform = '';
        
        // Horizontal swipe
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            // Swipe right (easy)
            if (deltaX > 80 && state === "answer") {
                cardEl.classList.add('swipe-right');
                setTimeout(() => {
                    cardEl.classList.remove('swipe-right');
                    recordDifficulty('easy');
                    nextCard();
                }, 200);
            }
            // Swipe left (hard)
            else if (deltaX < -80 && state === "answer") {
                cardEl.classList.add('swipe-left');
                setTimeout(() => {
                    cardEl.classList.remove('swipe-left');
                    recordDifficulty('hard');
                    nextCard();
                }, 200);
            }
        }
    }, { passive: true });
    
    // Quick action buttons
    document.getElementById('selectAllBtn').addEventListener('click', () => {
        lecturesEl.querySelectorAll('input[type=checkbox]').forEach(cb => {
            cb.checked = true;
            cb.parentElement.classList.add('selected');
        });
    });
    
    document.getElementById('clearAllBtn').addEventListener('click', () => {
        lecturesEl.querySelectorAll('input[type=checkbox]').forEach(cb => {
            cb.checked = false;
            cb.parentElement.classList.remove('selected');
        });
    });
    
    document.getElementById('studyUnlearnedBtn').addEventListener('click', () => {
        const checkboxes = lecturesEl.querySelectorAll('input[type=checkbox]');
        let hasUnlearned = false;
        
        checkboxes.forEach(cb => {
            const lectureName = cb.value;
            const items = allItems[lectureName] || [];
            
            // Check if this lecture has unlearned words
            const hasNewWords = items.some(item => !progress.learned[getWordHash(item)]);
            
            if (hasNewWords) {
                cb.checked = true;
                cb.parentElement.classList.add('selected');
                hasUnlearned = true;
            } else {
                cb.checked = false;
                cb.parentElement.classList.remove('selected');
            }
        });
        
        if (!hasUnlearned) {
            alert('Great job! All words have been studied at least once. üéâ');
        }
    });
    
    document.getElementById('reviewDifficultBtn').addEventListener('click', () => {
        const checkboxes = lecturesEl.querySelectorAll('input[type=checkbox]');
        let hasDifficult = false;
        
        checkboxes.forEach(cb => {
            const lectureName = cb.value;
            const items = allItems[lectureName] || [];
            
            // Check if this lecture has difficult words
            const hasDifficultWords = items.some(item => {
                const learned = progress.learned[getWordHash(item)];
                return learned && (learned.difficulty === 'hard' || learned.difficulty === 'medium');
            });
            
            if (hasDifficultWords) {
                cb.checked = true;
                cb.parentElement.classList.add('selected');
                hasDifficult = true;
            } else {
                cb.checked = false;
                cb.parentElement.classList.remove('selected');
            }
        });
        
        if (!hasDifficult) {
            alert('No difficult words found! All words are marked as easy. üåü');
        }
    });
    
    // Review Session button
    document.getElementById('reviewSessionBtn').addEventListener('click', () => {
        const reviewWords = [];
        
        // Get all words studied in last 3 days that were hard or medium
        const threeDaysAgo = Date.now() - (3 * 24 * 60 * 60 * 1000);
        
        for (const [hash, data] of Object.entries(progress.learned)) {
            if (data.lastSeen > threeDaysAgo && (data.difficulty === 'hard' || data.difficulty === 'medium')) {
                reviewWords.push(hash);
            }
        }
        
        if (reviewWords.length === 0) {
            alert('No words to review! Study some difficult words first.');
            return;
        }
        
        // Find and select lectures that contain these words
        const lecturesToSelect = new Set();
        
        reviewWords.forEach(hash => {
            const [heb, eng] = hash.split('::');
            // Find which lecture this word belongs to
            for (const [lectureName, items] of Object.entries(allItems)) {
                if (items.some(item => item.heb === heb && item.eng === eng)) {
                    lecturesToSelect.add(lectureName);
                }
            }
        });
        
        // Select those lectures
        lecturesEl.querySelectorAll('input[type=checkbox]').forEach(cb => {
            const should = lecturesToSelect.has(cb.value);
            cb.checked = should;
            cb.parentElement.classList.toggle('selected', should);
        });
        
        alert(`Review Session: ${lecturesToSelect.size} lectures selected with ${reviewWords.length} words to review!`);
    });
    
    // Suggest Lecture button
    document.getElementById('suggestLectureBtn').addEventListener('click', () => {
        suggestNextLecture();
    });
    
    // Mode selector
    document.getElementById('modeSelector').addEventListener('change', (e) => {
        studyMode = e.target.value;
        dbg('Study mode changed to:', studyMode);
    });
    
    // Sync button
    document.getElementById('syncBtn').addEventListener('click', async () => {
        const btn = document.getElementById('syncBtn');
        btn.disabled = true;
        btn.textContent = '‚è≥ Syncing...';
        
        try {
            await saveProgress();
            btn.textContent = '‚úì Synced!';
            setTimeout(() => {
                btn.textContent = '‚òÅÔ∏è Sync Now';
                btn.disabled = false;
            }, 2000);
        } catch (e) {
            btn.textContent = '‚úó Failed';
            setTimeout(() => {
                btn.textContent = '‚òÅÔ∏è Sync Now';
                btn.disabled = false;
            }, 2000);
        }
    });

(async function init() {
    try {
        dbg("init started", true);
        
        // Load saved progress from cloud
        await loadProgress();
        
        await loadDocument(currentView);
    } catch (e) {
        console.error(e);
        statusEl.textContent = "Error loading document: " + e.message;
    }
})();

async function loadDocument(viewMode) {
    try {
        const viewName = viewMode === 'chronological' ? 'Chronological Order' : 'By Theme';
        statusEl.textContent = `Loading ${viewName}...`;
        startBtn.disabled = true;
        
        const text = await fetchDocText();
        lectures = parseLectures(text, viewMode);

        dbg("lectures after parse", lectures);

        const itemsMap = {};
        Object.keys(lectures).forEach(name => {
            itemsMap[name] = extractItems(lectures[name].lines);
        });

        allItems = itemsMap;
        dbg("allItems", allItems);

        buildLectureChips(lectures);
        
        // Reset card state
        state = "idle";
        pool = [];
        questionEl.textContent = "";
        answerEl.textContent = "";
        cardHintEl.textContent = "Choose lectures and press Start.";
        modeLabelEl.textContent = "";
    } catch (e) {
        console.error(e);
        statusEl.textContent = "Error loading document: " + e.message;
    }
}

// Document selector event listeners
document.querySelectorAll('.doc-btn').forEach(btn => {
    btn.addEventListener('click', async () => {
        const viewMode = btn.dataset.doc;
        if (viewMode === currentView) return;
        
        // Update UI
        document.querySelectorAll('.doc-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        
        // Load new view
        currentView = viewMode;
        await loadDocument(viewMode);
    });
});
</script>
</body>
</html>
