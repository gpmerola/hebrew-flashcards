<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hebrew Flashcards</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body {
            font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
            margin: 0;
            padding: 0;
            background: #111;
            color: #f5f5f5;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        header {
            padding: 1rem 1.2rem;
            text-align: center;
            font-size: 1.1rem;
            background: #181818;
            border-bottom: 1px solid #333;
        }
        main {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 0.8rem 1.2rem 1.2rem;
            gap: 0.8rem;
        }
        #status {
            font-size: 0.9rem;
            color: #bbb;
        }
        #lectures {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin-top: 0.2rem;
        }
        .lecture-chip {
            padding: 0.3rem 0.7rem;
            border-radius: 999px;
            border: 1px solid #444;
            font-size: 0.85rem;
            cursor: pointer;
            user-select: none;
            line-height: 1.2;
            text-align: left;

        }
        .lecture-chip input {
            display: none;
        }
        .lecture-chip.selected {
            background: #2e7dff;
            border-color: #2e7dff;
            color: #fff;
        }
        #controls {
            display: flex;
            gap: 0.6rem;
            align-items: center;
            margin-top: 0.4rem;
        }
        button {
            padding: 0.5rem 0.9rem;
            border-radius: 999px;
            border: none;
            background: #2e7dff;
            color: #fff;
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
        }
        button:disabled {
            opacity: 0.5;
            cursor: default;
        }
        #modeLabel {
            font-size: 0.85rem;
            color: #bbb;
        }
        #card {
            margin-top: 0.8rem;
            flex: 1;
            border-radius: 1rem;
            border: 1px solid #333;
            background: #181818;
            padding: 1.2rem 1rem;
            display: flex;
            flex-direction: column;
            justify-content: center;
            text-align: center;
            cursor: pointer;
            user-select: none;
        }
        #cardHint {
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 0.6rem;
        }
        #question {
            font-size: 1.4rem;
            margin-bottom: 0.6rem;
            line-height: 1.3;
        }
        #answer {
            font-size: 1rem;
            color: #ddd;
            min-height: 1.2em;
            line-height: 1.4;
        }
        #footer {
            font-size: 0.8rem;
            color: #777;
            text-align: center;
            padding: 0.4rem 0.8rem 0.8rem;
        }
    </style>
</head>
<body>
<header>
    Hebrew Flashcards
</header>
<main>
    <div id="status">Loading words from Google Doc…</div>

    <div id="lectures"></div>

    <div id="controls">
        <button id="startBtn" disabled>Start</button>
        <div id="modeLabel"></div>
    </div>

    <div id="card">
        <div id="cardHint">Choose lectures and press Start.</div>
        <div id="question"></div>
        <div id="answer"></div>
    </div>
</main>
<div id="footer">
    Tap card once to reveal, tap again for the next word.
</div>

<script>

    function dbg(label, value) {
    console.log(`[DEBUG] ${label}:`, value);
    }


    function normalizeGoogleDocUrl(url) {
    if (url.includes("/pub")) {
        return url.replace(/\/pub(\?.*)?$/, "/pub?output=txt");
    }
    if (url.includes("/export")) {
        return url;
    }
    throw new Error("Unsupported Google Docs URL");
    }
    
    const DOC_ID = "1UVxgmP06_jXKVuc8vfRZqLFsXFrK22edaU-RQl2DHFs";
    const RAW_DOC_URL =
      "https://docs.google.com/document/d/e/2PACX-1vS9iILd7_1PfEdN8Gd-A1c7qOy7aZu_4Otg7gXDlxZnP0ZoXgRilCqsrud_gHBEkAydwSZG7H7wcUEC/pub";
    
    const EXPORT_URL = normalizeGoogleDocUrl(RAW_DOC_URL);

    let lectures = {};
    let allItems = {};
    let pool = [];
    let current = null;
    let state = "idle"; // "idle", "question", "answer"

    const statusEl = document.getElementById("status");
    const lecturesEl = document.getElementById("lectures");
    const startBtn = document.getElementById("startBtn");
    const cardEl = document.getElementById("card");
    const cardHintEl = document.getElementById("cardHint");
    const questionEl = document.getElementById("question");
    const answerEl = document.getElementById("answer");
    const modeLabelEl = document.getElementById("modeLabel");

    async function fetchDocText() {
        const res = await fetch(EXPORT_URL);
        if (!res.ok) {
            throw new Error("HTTP " + res.status);
        }
    
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, "text/html");
    
        // Get all paragraphs and preserve structure
        let lines = [];
        const elements = doc.querySelectorAll('p, h1, h2, h3, h4, h5, h6, span, div');
        
        elements.forEach(el => {
            const text = el.textContent.trim();
            if (text && text.length > 0) {
                // Skip style/script content
                if (!text.includes('{') && !text.includes('margin:0')) {
                    lines.push(text);
                }
            }
        });
        
        // If no elements found or too few, try splitting the body text
        if (lines.length < 10) {
            dbg("fallback parsing", true);
            let text = doc.body.textContent || "";
            
            // Remove CSS and metadata
            text = text.replace(/\{[^}]*\}/g, '');
            text = text.replace(/^.*?Updated automatically every \d+ minutes/i, '');
            
            // Split on Lezione markers more aggressively
            const parts = text.split(/(Lezione\s+\d+[^א-ת]*[א-ת][^L]*?)(?=Lezione|\s*$)/gi);
            
            lines = [];
            for (let part of parts) {
                part = part.trim();
                if (part && part.length > 5 && !part.includes('{')) {
                    // Split individual words by looking for Hebrew-dash-English-dash-transliteration pattern
                    const wordLines = part.split(/(?=[א-ת]{2,}\s*[–—-]\s*[a-zA-Z])/);
                    lines.push(...wordLines.map(l => l.trim()).filter(l => l.length > 0));
                }
            }
        }
        
        const result = lines.join('\n');
        dbg("normalized text preview", result.slice(0, 800));
        dbg("total lines after split", lines.length);
    
        return result;
    }

function parseLectures(text) {
    const lectures = {};
    let currentKey = null;
    let awaitingTitle = false;

    const lines = text.split(/\r?\n/);
    dbg("total lines", lines.length);

    lines.forEach((raw, index) => {
        const line = raw
            .replace(/^\uFEFF/, "")
            .replace(/[\u00A0\u200B\u200C\u200D]/g, " ")
            .replace(/\s+/g, " ")
            .trim();

        if (!line) return;

        if (line.toLowerCase().includes("lezione")) {
            dbg(`line ${index} contains 'Lezione'`, line);
        }

        if (/^Lezione\s+\d+/i.test(line)) {
            dbg(`LECTURE DETECTED at line ${index}`, line);

            currentKey = line.split(/[–—-]/)[0].trim();
            const titlePart = line.substring(currentKey.length).replace(/^[–—-]\s*/, '').trim();
            
            lectures[currentKey] = {
                name: currentKey,
                title: titlePart || "",
                lines: []
            };
            awaitingTitle = false;
            return;
        }

        if (currentKey) {
            lectures[currentKey].lines.push(line);
        }
    });

    dbg("parsed lectures object", lectures);
    dbg("lecture count", Object.keys(lectures).length);

    return lectures;
}

function extractItems(lines) {
    const items = [];

    dbg("extractItems called with", lines.length);

    for (const rawLine of lines) {
        const normalized = rawLine.replace(/[–—]/g, "-");
        const parts = normalized.split(/\s*-\s*/);

        if (parts.length >= 3) {
            const heb = parts[0].trim();
            const eng = parts[1].trim();
            const trans = parts.slice(2).join(" - ").trim();

            if (heb && eng && trans) {
                items.push({ heb, eng, trans });
            }
        }
    }

    dbg("items extracted", items.length);
    return items;
}

function buildLectureChips(lecturesMap) {
    dbg("buildLectureChips called with", Object.keys(lecturesMap));
    lecturesEl.innerHTML = "";

    const names = Object.keys(lecturesMap).sort((a, b) => {
        const na = parseInt(a.replace(/\D+/g, ""), 10);
        const nb = parseInt(b.replace(/\D+/g, ""), 10);
        return na - nb;
    });

    names.forEach(name => {
        const data = lecturesMap[name];
        dbg("rendering lecture chip", data);

        const chip = document.createElement("label");
        chip.className = "lecture-chip";

        const input = document.createElement("input");
        input.type = "checkbox";
        input.value = name;

        const text = document.createElement("span");
        text.innerHTML = data.title
            ? `<strong>${data.name}</strong><br><span style="font-size:0.75rem;opacity:.8">${data.title}</span>`
            : data.name;

        chip.appendChild(input);
        chip.appendChild(text);

        chip.addEventListener("click", e => {
            if (e.target.tagName !== "INPUT") {
                input.checked = !input.checked;
            }
            chip.classList.toggle("selected", input.checked);
            e.preventDefault();
        });

        lecturesEl.appendChild(chip);
    });

    statusEl.textContent = "Lectures loaded. Select one or more and press Start.";
    startBtn.disabled = false;
}


    function collectSelectedItems() {
        const checkboxes = lecturesEl.querySelectorAll("input[type=checkbox]");
        const chosen = [];
        checkboxes.forEach(cb => {
            if (cb.checked) {
                chosen.push(cb.value);
            }
        });

        const result = [];
        chosen.forEach(name => {
            if (allItems[name]) {
                result.push(...allItems[name]);
            }
        });
        return result;
    }

    function nextCard() {
        if (!pool.length) {
            pool = collectSelectedItems();
            if (!pool.length) {
                questionEl.textContent = "";
                answerEl.textContent = "";
                cardHintEl.textContent = "Select at least one lecture and press Start.";
                state = "idle";
                return;
            }
        }

        current = pool[Math.floor(Math.random() * pool.length)];
        const mode = Math.random() < 0.5 ? "heb_to_eng" : "eng_to_heb";

        answerEl.textContent = "";
        cardHintEl.textContent = "Tap to reveal answer.";
        state = "question";

        if (mode === "heb_to_eng") {
            questionEl.textContent = `${current.heb}   (${current.trans})`;
            modeLabelEl.textContent = "Translate to English.";
            current.mode = mode;
        } else {
            questionEl.textContent = current.eng;
            modeLabelEl.textContent = "Translate to Hebrew.";
            current.mode = mode;
        }
    }

    function showAnswer() {
        if (!current) return;

        if (current.mode === "heb_to_eng") {
            answerEl.textContent = `${current.eng} – ${current.trans}`;
        } else {
            answerEl.textContent = `${current.heb}   (${current.trans})`;
        }
        cardHintEl.textContent = "Tap for next word.";
        state = "answer";
    }

    startBtn.addEventListener("click", () => {
        pool = collectSelectedItems();
        if (!pool.length) {
            alert("Select at least one lecture.");
            return;
        }
        nextCard();
    });

    cardEl.addEventListener("click", () => {
        if (state === "question") {
            showAnswer();
        } else if (state === "answer") {
            nextCard();
        }
    });

(async function init() {
    try {
        dbg("init started", true);

        const text = await fetchDocText();
        lectures = parseLectures(text);

        dbg("lectures after parse", lectures);

        const itemsMap = {};
        Object.keys(lectures).forEach(name => {
            itemsMap[name] = extractItems(lectures[name].lines);
        });

        allItems = itemsMap;
        dbg("allItems", allItems);

        buildLectureChips(lectures);
    } catch (e) {
        console.error(e);
        statusEl.textContent = "Error loading document: " + e.message;
    }
})();
</script>
</body>
</html>
